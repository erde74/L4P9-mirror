//%%%%  Tentative malloc( ) ported from Minix %%%%%

#define NULL     (void*)0 
#define	ptrint		int

#define BRKSIZE		4096

#define	PTRSIZE		((int) sizeof(void *))
#define Align(x,a)	(((x) + (a - 1)) & ~(a - 1))
#define NextSlot(p)	(* (void **) ((p) - PTRSIZE))
#define NextFree(p)	(* (void **) (p))


extern char *  _sbrk(int);
extern int     _brk(char *);
static void *  _bottom, *_top, *_empty;

void  free(void *ptr);


static void * memcpy(void *s1, const void *s2, int n)
{
  char *p1 = s1;
  const char *p2 = s2;
  if (n) {
    n++;
    while (--n > 0) {
      *p1++ = *p2++;
    }
  }
  return s1;
}


static int grow(int  len)
{
  register char *p;

  // assert(NextSlot((char *)_top) == 0);
  if ((char *) _top + len < (char *) _top
      || (p = (char *)Align((ptrint)_top + len, BRKSIZE)) < (char *) _top ) {
        //      errno = ENOMEM;
	return(0);
  }
  if (_brk(p) != 0)
	return(0);
  NextSlot((char *)_top) = p;
  NextSlot(p) = 0;
  free(_top);
  _top = p;
  return 1;
}

void * malloc(unsigned int size)
{
  register char *prev, *p, *next, *new;
  register unsigned len, ntries;

  if (size == 0)
	return NULL;

  for (ntries = 0; ntries < 2; ntries++) {
	if ((len = Align(size, PTRSIZE) + PTRSIZE) < 2 * PTRSIZE) {
	        //  errno = ENOMEM;
		return NULL;
	}
	if (_bottom == 0) {
		if ((p = _sbrk(2 * PTRSIZE)) == (char *) -1)
			return NULL;
		p = (char *) Align((ptrint)p, PTRSIZE);
		p += PTRSIZE;
		_top = _bottom = p;
		NextSlot(p) = 0;
	}

	for (prev = 0, p = _empty; p != 0; prev = p, p = NextFree(p)) {
		next = NextSlot(p);
		new = p + len;	/* easily overflows!! */
		if (new > next || new <= p)
			continue;		/* too small */
		if (new + PTRSIZE < next) {	/* too big, so split */
			/* + PTRSIZE avoids tiny slots on free list */
			NextSlot(new) = next;
			NextSlot(p) = new;
			NextFree(new) = NextFree(p);
			NextFree(p) = new;
		}
		if (prev)
			NextFree(prev) = NextFree(p);
		else
			_empty = NextFree(p);
		return p;
	}
	if (grow(len) == 0)
		break;
  }
  // assert(ntries != 2);
  return NULL;
}

void * realloc(void * oldp,  unsigned int size)
{
  register char *prev, *p, *next, *new;
  char *old = oldp;
  int   len, n;

  if (old == 0)
	return malloc(size);
  if (size == 0) {
	free(old);
	return NULL;
  }
  len = Align(size, PTRSIZE) + PTRSIZE;
  next = NextSlot(old);
  n = (int)(next - old);	// old length 

  // extend old if there is any free space just behind it
  for (prev = 0, p = _empty; p != 0; prev = p, p = NextFree(p)) {
	if (p > next)
		break;
	if (p == next) {	/* 'next' is a free slot: merge */
		NextSlot(old) = NextSlot(p);
		if (prev)
			NextFree(prev) = NextFree(p);
		else
			_empty = NextFree(p);
		next = NextSlot(old);
		break;
	}
  }
  new = old + len;

  // Can we use the old, possibly extended slot?  /
  if (new <= next && new >= old) {	/* it does fit */
	if (new + PTRSIZE < next) {	/* too big, so split */
		/* + PTRSIZE avoids tiny slots on free list */
		NextSlot(new) = next;
		NextSlot(old) = new;
		free(new);
	}
	return old;
  }
  if ((new = malloc(size)) == NULL)	/* it didn't fit */
	return NULL;
  memcpy(new, old, n);			/* n < size */
  free(old);
  return new;
}

void  free(void *ptr)
{
  char *prev, *next;
  char *p = (char*)ptr;

  if (p == 0)
	return;

  // assert(NextSlot(p) > p);
  for (prev = 0, next = _empty; next != 0; prev = next, next = NextFree(next))
	if (p < next)
		break;
  NextFree(p) = next;
  if (prev)
	NextFree(prev) = p;
  else
	_empty = p;
  if (next) {
        // assert(NextSlot(p) <= next);
	if (NextSlot(p) == next) {		/* merge p and next */
		NextSlot(p) = NextSlot(next);
		NextFree(p) = NextFree(next);
	}
  }
  if (prev) {
        // assert(NextSlot(prev) <= p);
	if (NextSlot(prev) == p) {		/* merge prev and p */
		NextSlot(prev) = NextSlot(p);
		NextFree(prev) = NextFree(p);
	}
  }
}


//=================================================


#if 1 //KM--Bad programming------------------------------

extern int  _end;  
char *_brksize = (char *)&_end;

// extern int  _end[1024];  //1024: safe zone. May be zero ?
// char *_brksize = (char *)&_end[1023];

#else  //original ------------------------------------------
   extern char *_brksize;
#endif //---------------------------------------------------


int brk(void *addr)
{
  unsigned   reqbrk = (unsigned)addr; 
  unsigned   oldbrk = (unsigned)_brksize;

  _brksize = addr;

  //  printfz("BRK[%x: %x -> %x] \n", reqbrk, oldbrk, _brksize); //------ 
  return(0);
}


int _brk(char  *addr)
{
  return  brk(addr);
}


//-----------------------------------------------------------
void * sbrk(unsigned int incr)
{
  char *newsize, *oldsize;

  oldsize = _brksize;
  newsize = _brksize + incr;
  //printf("SBRK  oldsize= %x delta= %x  newsize= %x \n", 
  //	 oldsize, incr, newsize);
  if ((incr > 0 && newsize < oldsize) || (incr < 0 && newsize > oldsize))
	return( (char *) -1);
  if (brk(newsize) == 0)
	return(oldsize);
  else
	return( (char *) -1);
}


char *_sbrk(int incr)
{
  return  sbrk(incr);
}


#if 0
#include  <stdio.h>

void main()
{
  int  i;
  char *p;
  for (i = 0; i<16; i++) {
    p = malloc(i*16);
    printf ("<%d> %x \n", i, p);
  }
}
#endif
