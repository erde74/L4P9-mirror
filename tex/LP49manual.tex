\documentstyle{jreport}
% \documentstyle{jarticle}
% \documentstyle[twocolumn]{jarticle}
\input epsf
\input comment.sty

\topmargin = 0cm
\oddsidemargin = 0cm
\evensidemargin = 0cm
\textheight = 24cm
\textwidth = 17cm

\setcounter{secnumdepth}{2}

%-----------------------------
\begin{document}

\title{\huge\bf
LP49の利用説明書
}

\author{$H_2O$}
%\author{色は  匂へと  散りぬるを}

% \eauthor{
%  Katsumi Maruyama, Kazuya Hidaka, Soichiro Hidaka, Hirotatsu Hashizume, 
% }

% \affiliation{国立情報学研究所   National Institute of Informatics}

\maketitle

\tableofcontents
%%%%%
\part{ＬＰ４９の基本}

\chapter{LP49の基本構想}
\section{LP49構造の概要}
   OSは、応用プログラム (あるいはユーザ) に対して
   "サービス"や"リソース"利用を提供する基盤である。
   OSは、処理性能とともに、あるいはそれ以上に、
   信頼性・頑強性・維持管理性が重要である。
   従って、構成要素のモジュール化、疎結合化（Ex. メッセージ結合）、
   障害の外波及防止と部分再開などが行い易いマイクロカーネル型OSが有利である。

   ＯＳは多大な機能をもつだけに、スクラッチから全部を作るには巨大な資金とプロジェクトが必要である。
   幸いなことに、Ｌ４マイクロカーネル（独・カールスルーエ大学）と, Plan 9 OS (米・Bell研究所)
   という先進的な成果があり、かつ共にオープンソースとなっている。
   これを活用することにより、極小プロジェクト (約1名×数年)
   で我々の目標を実現しようというわけである。

\begin{figure}[hbt]
  \begin{center}
   \epsfxsize=440pt
   \epsfbox{fig/LP49general.eps}
    \caption{LP49全体構成}
    \label{fig:LP49general}
  \end{center}
\end{figure}


   LP49 は、図 \ref{fig:LP49general} に示すように、以下の階層かなできている。

\begin{description}     
\item[L4 マイクロカーネル]
        メモリ空間管理、スレッド管理、メッセージ通信を効率よく実現している。
       この部分だけがカーネルモードで動作する。
    
\item[HVM (Hypervisor monitor)]
        LP49の startup と、メモリページ管理 (Pager) をおこなう。
        HVM という名前は、将来仮想マシンとしての機能をくみこむ意図で付けたが, 
        現在は仮想マシン機能は実装していない。
        ページ管理は現在のところ必要最低限しか実装していないが、
         L4マイクロカーネルの強力と融通性を発揮できる分野であり、今後大いに発展させ
        る予定である。
        
\item[LP49-CORE]
        名前空間の管理、サーバのマウント, 
        プロセス管理システムコールの処理、 
        ファイル系システムコール（該当サーバ/サーバントに実行させる）
        の機能を持つ。
    
\item[サーバ]
        サーバは、9P プロトコル (Plan9 のサーバインタフェース) メッセージによって、
        サービスを提供する。 
        メッセージは、TCP接続 もしくは PIPE (ノード内の場合) を介してやり取りされる。
    
\item[ライブラリ]
       応用プログラム APL は、使い慣れたシステムコール呼び出しでもってサービスを受けられる。
      ライブラリは、これをメッセージになおして COREプロセスに送る。
    
\item[シェル (qsh, rc)]
        シェルとしては、qsh と rc を容易している。
        ``Qsh''は LP49 のデバッグ用に作ったシェルで、色々なシステムコールを組込みコマンドとして提供している。
        ``rc''は Plan9 の強力なシェルである(移植進行中)。qsh の中から起動できる。
   
\item[APL: 応用プログラム]
\end{description}


\section{LP49の基本発想}

{\bf\flushleft (1) マイクロカーネル}

   OSの疎結合モジュール化、デバイスドライバを含むプログラムのユーザモード化、
  個別プロセス再開による耐障害強化、マルチスレッドプログラミングの容易化のために、
  マイクロカーネル型OSとした。
  マイクロカーネルは、スレッドとメッセージの効率が高く、融通性も高くかつシンプルな
  L4 を利用した。
  OS全体を管理するモジュールは、``L4マイクロカーネル''の１タスク(論理空間+スレッド)として
  ユーザモードで実行させている。
  これを ``LP49-CORE'' と呼ぶ。　


{\bf\flushleft (2) すべてのリソース・サービスをファイルトリーとして扱う}

   Unixでは、すべてのリソースが階層的ファイルトリー上に名前付けされており（名前空間）、
  ファイルとしてアクセス出きることを目指したが、
  この理念はネットワーク(NW)をはじめとして早期に破綻した。
  LP49 では Plan9 を踏襲して、NWも含めてすべてアクセス対象を
  トリーディレクトリー上の名前で識別でき、
  ファイルインタフェース(open(), read(), write(), 等) で操作されるオブジェクト
  として扱っている。

{\bf\flushleft (3) サービス部品：サーバとサーバント}

  OSが提供するサービスには、
  DOSファイルサービス、EXT2ファイルサービスといった高位サービスと、
  ハードウェア駆動、モジュール間通信、NW接続、サービス登録簿といった低位サービス
  とがある。

  前者は、個々に独立性が高く、規模も大きくなりがちなので、
  サービス毎にユーザモードで走るプロセスとして実現する。これを{\bf サーバ}と呼ぶ。
  ローカルでもリモートでも同等に使えるように、サーバはメッセージインタフェースとした。
  ユーザモードプロセスなので、プログラム開発の容易化のみならず、
  障害時もそのサーバだけを停止・再開することで耐障害性も強化される。

  後者は、共通部品的であり、より実行速度が重視されるので、
  独立したプロセスとはせず LP49-CORE内のモジュールとして実装することとした。
  このモジュールを{\bf サーバント}と呼んでいる。
  サーバントは、統一インタフェースを持つコンポーネントである。
  同一サービスをサーバで実装することも、サーバントで実装することも可能である。

{\bf\flushleft (4) マルチサーバと9Pプロトコル}

  サーバのプロトコル（メッセージインタフェース）は、
  サーバが提供できる機能と性能を決定する。
  いくら強力であっても、独自プロトコルは世の中に普及させることは至難である。
  幸い Plan9の{\bf 9pプロトコル}は、
  {\tt attach(), walk(),open(), create(), 
  read(), write(), clunk(), remove(), stat(), wstat() }
  等のメッセージからなり、
  低レベル制御も可能で融通性が高いので、これを採用した。
  9Pプロトコルを採用した副産物として、少ない修正で
  Plan9のサーバをLP49に移植することも可能になった。

{\bf\flushleft (5) 名前空間とその接続}

  前述のように、サーバもサーバントも内部のアクセス対象はファイルトリー上の
ファイルとして抽象化されており、UNIXでいうファイルシステムである。
つまり, それぞれが名前空間をなしている。

図 \ref{fig:NS-server-servant} に示すように、
ルートファイルシステム({\bf RootFS}: 実はこれもサーバント)を出発点とする{\bf 名前空間}に、
サーバやサーバントをを接続（マウント）することにより、ユーザに見えるようにする。
``/dev'' には各種デバイスサーバントが、``/net''にはプロトコルスタックが接続されている。
サーバはリモートの可能性もあるので、マウントの仕組みは後で説明する。

\begin{figure}[htb]
  \begin{center}
   \epsfxsize=360pt
   \epsfbox{fig/NS-server-servant.eps}
    \caption{サーバ、サーバントと名前空間}
    \label{fig:NS-server-servant}
  \end{center}
\end{figure}


{\bf\flushleft (6) プロセス個別名前空間}

  UNIXではファイルシステムの mount は root のみが行え、
  名前空間は全プロセスで共通である。
  これに対し、Plan9/LP49 の名前空間は、
  各プロセス毎に自前の名前空間（{\bf 個別名前空間}）を持つことができる。
  名前空間はアクセス保護の役目を持つので、緻密なセキュリティー管理を
  実現できる。


%%%%%%
\chapter{LP49の立ち上げ方}
\section{ブートメディア}

     LP49は、ブートローダとして GNU GRUBを用いている。
     LP49は、実機 (PC-AT), qemu エミュレータ、VMware 仮想マシンなどの上で走る。
     なお、以下の説明は作業環境として Linux を想定している。
     LP49 のブートは、現在の所CD-ROM 及びフロッピーディスク (1.4MB オブジェクトと 2.8MB) 
     からブート可能である。
     これらのイメージファイルは、LP49-yymmdd.tarファイルに載せてある。
     フロッピーディスクは容量が小さすぎるので、今後は CD-ROM のみをサポートしていく予定である。
\begin{itemize}
\item     lp49-boot.cd:  CD-ROM イメージ (ISO9660形式)
\item     lp49-boot.fd: 1.4MBフロッピーイメージ
\item     lp49-boot-x2.fd: 2.6MBフロッピーイメージ
\end{itemize}


{\bf (1)  CD-ROM からのブートする}

  \begin{itemize}
       \item  実機の場合\\
          CD-ROMイメージファイル lp49-boot.cd を CD-ROMに書き込み、CD-ROMからブートする。
       \item  QEMU の場合 \\
          CD-ROMイメージファイル lp49-boot.cd を用いて qemuを起動する。\\
            \verb| # qemu -cdrom lp49-boot.cd -std-vga |  
       \item  VMware の場合 \\
          CD-ROMイメージファイル lp49-boot.cd を用いて VMwareを起動する。
  \end{itemize}

{\bf (2) GRUBがメニューリストを表示する}
   \begin{description}
   \item[LP49: CD BOOT (Hvm + Pc + Qsh + DosSrv + 9660Srv)]  デバグ用シェル ``qsh''が使われる。
   \item[LP49: CD BOOT (Hvm + Pc + Init + DosSrv + 9660Srv)] Plan9 の強力シェル‘``rc'' が使われる。
   \item[....]
   \end{description}
    今のところ、最初のデバグ用シェル ``qsh''を選択すること。
    2番めのPlan9 の強力シェル‘``rc''はまだ開発中であり、動かない部分がある。

{\bf (3)  LP49 が立ち上がり、CD(default)かFDかと聞いてきたら Returnキイを押す}

         以上により、LP49 のプロンプト 
         (``qsh''の場合 \verb| LP49[/]: |, ``rc''の場合は \verb| [lp49]  |）が表示されるので、
         Unix類似のシェル組み込みコマンド ({\tt ls, cd, echo, cat, pwd}など) を入力して、
         動作を確かめられたい。




%%
\begin{comment}
\section{フロッピーからブートする場合}
\begin{enumerate}
\item フロッピーから起動する。
  \begin{itemize}
  \item  実機の場合\\
          フロッピーイメージファイル lp49-boot.fd をフロッピーに書き込み、フロッビーからブートする。
  \item  QEMU の場合\\
          フロッピーイメージファイル lp49-boot.fd を用いて qemuを起動する。
          qemuは 2.8MBフロッピーが使える。\\
            \verb|# qemu -fda  lp49-boot-x2.fd -std-vga|  

  \item   VMware の場合\\
          フロッピーイメージファイル lp49-boot.fd  を用いて VMwareを起動する。
  \end{itemize}

\item メニューが表示されたら LP49: FD BOOT (....) を選択する。
\item     LP49 が立ち上がり、CDかFDかと聞いてきたら f と打ちReturnキイを押す。
\end{enumerate}
\end{comment}


%%%%
\section{名前空間: ディレクトリー}

    ``Directory tree'' は、いわゆるファイルだけでなく
    ほとんどのリソースやサービスも含めて、
    階層的な名前（パス名）でアクセスするための仕組みである。
    つまり、リソースやサービスを名前で識別するので ''名前空間'' とよぶ。

   LP49は、立ち上げ時に各種のリソースやサービスを名前空間につなぐ。
   立ち上げたときの名前空間を以下に示す。

{\bf 【名前空間＝ディレクトリ構成】}\\
{\small
\begin{verbatim}

       --- / ---+-- bin/    <- - - ここには各種コマンドが見える
                |                 (実際には /t/bin/ がマウントされている)   
                |
                |
                |-- dev/ --+-cons       ← 各種デバイスがバインドされている。
                |          |   :           
                |                          
                |-- env/       ← 環境変数   
                |-- fd/                     
                |-- net/    <- - - ネットワーク関係が見える
                |
                |-- proc/   <- - - Procファイル
                |-- srv/    <- - - サーバ登録簿 (service registray) 
                |-- root/                                           
                |-- n/      <- - - リモートのサーバをマウントする場所
                |-- c/            
                |-- ums/  
                |-- exportfs/                                       
                |                                                  
                |-- t/ --+-bin/--+- コマンド         --*        
                |        |       |   :                 | これらはブートCDに載っている。
                |        |                             |                              
                |        +-boot/---+- hvm.gz           | ブートCDのファイルシステムは、"/t" 
                |        |         |- pc.gz            | にマウントされているので,
                |        |         |- qsh.gz           | この場所に見える。              
                |        |                             |               
                |        +-l4/  ---+-- kickstart.gz    |               
                |                  |-- l4ka.gz         |               
                |                  |-- sigma0.gz     --*               
                |                                                 
                |-- rc/--- rcmain                    --* これらは、ルートファイルシステム
                |-- lib/ --- namespace                 | devrootfs.c が提供しており、/に
                |-- mnt/ --- exportfs/ --+- 0/ ---     | ユニオンマウントされているので、
                |                        |- 1/ ---     | この場所に見える。
                |                        |- 2/ ---     |            
                |-- tmp/                               |                     
                |-- work/ --                           | RAMファイルシステムなので、
                |-- usr/ --                            | ファイルの生成・書き込みも可能。
                +-- home/ ---+-- eve/                  |                                
                             |-- adm/                  |
                                                     --*

\end{verbatim}    
}

   UNIX の名前空間は、全プロセスに共通であるのに対し、
   LP49 の名前空間は各プロセス毎に自前の "個別名前空間" を持つことができる（後述）。  



%%%%
\section{コマンドを試してみる}

{\bf (1) qshシェル組み込みコマンドを入力してみる}

\begin{verbatim}
    LP49[/]: echo  abcdefghijklmn
    LP49[/]: cd /t/bin
    LP49[/t/bin]: ls
    LP49[/t/bin]: cat ex2
\end{verbatim}


{\bf (2) 実行ファイルを走らせてみる}

    ``\verb|spawn <ファイルのパス名> <引数>|'', もしくは spawnを省略して
    ``\verb|<ファイルのパス名> <引数>|'' と入力する。
    同名のシェル組み込みコマンドがある場合には``spawn''を付ければ実行ファイルが実行される。

\begin{verbatim}
    LP49[/t/bin]: spawn ls -l      <- - lsファイルが実行される
    LP49[/t/bin]: ls               <- - 組み込みlsコマンドが実行される
    LP49[/t/bin]: ex2 2            <- - デモプログラムファイルが実行される
    LP49[/t/bin]: cd /
    LP49[/]: /t/bin/ex2 4
\end{verbatim}


{\bf (3) Qemu の場合、フラクタル図を描かせてみる}
        Qemu上で走らせている場合は, 次のように入力してみよう。
        Mandelbrot のフラクタル図が表示される。
\begin{verbatim}
    LP49[/]: d vga 
\end{verbatim}

{\bf (4) ファイルを作って書き込んでみる}

     LP49の立ち上げ時に、``/tmp'' には RAMファイルシステムがマウントされている
     (この表現は厳密には正しくないことが、後で説明される)。
    したがって、このディレクトリーを使えばハードディスクを使わずとも
    ファイルを生成することが可能である。
    ``qsh''はデバッグ用のシェルなので、create(), write(), read()などの 
    システムコールに対応したコマンドも組み込まれている。

【利用例】\\
\begin{verbatim}
     *-----------------------------------
     |    LP49[/]: cd  /tmp                                     
     |    LP49[/tmp]: create  -w  zzz 0666                       
     |       ....  FDの値を返す .....   ここでは FD=10 とする。 
     |    LP49[/tmp]: write  10   AAABBBCCCDDDEEEFFFGGGHHH      
     |    LP49[/tmp]: pread  10  0                              
     |       AAABBBCCCDDDEEEFFFGGGHHH                           
     *-----------------------------------
\end{verbatim}
           
{\bf (4) cmd.zip ファイルの展開}

    LP49はファイル圧縮 zip, unzip も備えている。
    いくつかの代表的コマンドは ZIP ファイルに圧縮して t/bin/cmd.zip として載せてある。
    以下の手順で、このファイルを /tmp に展開することができる。

【利用例】\\
\begin{verbatim}
    LP49[/]: cd  /usr  
    LP49[/tmp]: unzip  -f  /t/bin/cmd.zip  <- - ブートCD上の t/bin/cmd.zip を解凍する。
    LP4p[/tmp]: ls   
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%
{\bf\flushleft 【参考】ブートCD-ROMの内容}

    TARファイル LP49-yymmdd.tar には、CD-ROMイメージ lp49-boot.cd が用意されている。
    ブートCD-ROMイメージには、以下が含まれている。

{\small
\begin{verbatim}
        ---+--boot/ --+--grub/ --+-menu.lst
           |          |          +-stage2-eltorito (grubのプートコード)
           |          |                  
           |          |--hvm.gz         ← LP49 起動とページャー
           |          |--pc.gz          ← LP49 Coreプロセス
           |          |--qsh.gz         ← LP49 簡易シェル       
           |          |--dossrv.gz      ← LP49 DOSファイルサーバー
           |                                
           +--l4 ----+ -kickstart-0707.gz        ← L4 の起動
           |         | -l4ka-0707.gz             ← L4マイクロカーネル 
           |         | -sigma0-0707.gz           ← L4 のPager
           |                                
           +--bin/ - -+--cmd.zip        ← いくつかのコマンドを入れたZIPファイル 
                      |--...            
                      |--srv            ← LP49 srvコマンド
                      |--ex2            ← LP49  デモプログラム   
                      |--... 
\end{verbatim}     
}


\begin{comment}
\section{QSHからブートフロッピーにアクセスしてみる}
      簡易シェル QSH は、立ち上げ時にブートCD-ROMを /t ディレクトリに接続するので、
        そのままアクセス可能。

\begin{verbatim}
     *---------------------------------------------------------------
     |  LP49[/]: ls                    ← ルートディレクトリのリストが表示される。           
     |  LP49[/]: ls   /t               ← CD-ROM ルートディレクトリのリストが表示される。    
     |  d rwxrwxrwx       0   /t            tdq</ 0 16>   <Eve Eve>                         
     |  ... this directory contaiss ...                                                     
     |  d rwxrwxrwx       0   boot/    .....  ← LP49 のコア他が載っているdirectory          
     |  d rwxrwxrwx       0   bin/     ....   ← LP49 の応用プログラムが載っているdirectory  
     |  d rwxrwxrwx       0   l4/      ....   ←L4マイクロカーネル本体が載っているdirectory  
     |  LP49[/]: cd   /t/bin                                                                
     |  LP49[/c/bin]: ls                                                                    
     |     /c/bin directoryのリストが表示される。                                           
     |  LP49[/c/bin]: cd                                                                    
     |  LP49[/ ]: bind /t/bin  /bin       ←  /t/bin directory を /bin にマウントする。      
     |  LP49[/]: ls /bin                                                                    
     *----------------------------------------------------------------
\end{verbatim}

\section{ブートフロッピーの内容}

      TARファイル LP49-yymmdd.tar には、ブートフロッピーイメージが用意されている。
    LP49 を実機走らせる場合には dd コマンドでフロッピーにコピーする。
    Qemu やVMwareで走らせる場合には、これをフロッピーイメージとして利用する。

\begin{itemize}
\item   lp49-boot.fd   →  1.44 MBフロッピーイメージなので実機でも使える。
\item    lp49-boot-x2.fd  → 2.88 MBフロッピーイメージ。Qemu の場合は、容量が大きいのでこちらが便利。
\end{itemize}
    
      ブートフロッピーイメージには、以下が含まれている。

{\small
\begin{verbatim}
        ---+-- boot/ --+-- grub/ --- menu.lst
           |           |             
           |           |-- hvm.gz         ← LP49 起動とページャー
           |           |-- pc.gz          ← LP49 Coreプロセス
           |           |-- qsh.gz         ← LP49 簡易シェル   
           |           |-- dossrv.gz      ← LP49 DOSファイルサーバー
           |                                                  
           +-- l4 ----+-- kickstart-0707.gz        ← L4 の起動
           |          |-- l4ka-0707.gz             ← L4マイクロカーネル 
           |          |-- sigma0-0707.gz           ← L4 のPager
           |                                                  
           +-- bin/ ---+-- cmd.zip        ← いくつかのコマンドを入れたZIPファイル
                       |-- srv            ← LP49 srvコマンド
                       |-- ex2            ← LP49  デモプログラム
                       |--...            
                       |--... 
\end{verbatim}
}

     フロッピーは容量が小さいので、多くのコマンドを載せることはできない。
   そこで、いくつかの代表的コマンドは ZIP ファイルに圧縮して b/cmd.zip として載せてある。

\section{QSHからブートフロッピーにアクセスしてみる}

      簡易シェル QSH は、立ち上げ時にブートフロッピーを /t ディレクトリに接続するので、
        そのままアクセス可能。

\begin{verbatim}
     *----------------------------------------------
     |  LP49[/]: ls                                                              
     |     ルートディレクトリのリストが表示される。                              
     |  LP49[/]: ls   /t                                                         
     |  d rwxrwxrwx       0   /t            tdq</ 0 16>   <Eve Eve>              
     |  ... this directory contaiss ...                                          
     |  d rwxrwxrwx       0   BOOT/    .....  ←  GRUBのdirectory                 
     |  d rwxrwxrwx       0   a/       ....   ← LP49 のコアが載っているdirectory 
     |  d rwxrwxrwx       0   b/       ....   ← LP49 の応用プログラムが載っているdirectory 
     |  - r--r--r--   64410   l4ka-0707.gz      ....   ←  L4マイクロカーネル本体   
     |  - r--r--r--   31214   kickstart-0707.gz ....   ←  L4のstartup              
     |  - r--r--r--   33318   sigma0-0707.gz    ....   ←  L4の sigma0 ページャ     
     |  LP49[/]: cd   /t/b                                                         
     |  LP49[/t/b]: ls                                                             
     |     /t/b directoryのリストが表示される。                                    
     *----------------------------------------------
\end{verbatim}

\section{フロッピーの接続法(参考)}

    ◎フロッピードライバの接続  

      〇 フロッピードライバは bindコマンドで接続され、/dev/fd0disk として見えるようになる。

\begin{verbatim}
          LP49[/]: bind -a #f /dev      ←  Floppy が /dev/fd0disk として接続される
                                            #f はフロッピードライバを意味する
                                            -a は after の略で /dev の最後に接続する
          LP49[/]: ls  /dev           ←    fd0disk, fd0ctl などが見える
\end{verbatim}
    

    【参考】簡易シェル qsh.c では、スタート時に以下の dosstart( ) を実行している。

\begin{verbatim}
            int dosstart() {
                chdir("/");
                bind("#s", "/srv", 4);
                bind("#f", "/dev", 2);
                fd = open("/srv/dos", ORDWR);
                rc = mount(fd, -1, "/t", 2, "/dev/fd0disk");
                return  rc;
             }      
\end{verbatim}

\end{comment}


%%%%%%%%%%%%%%
\chapter{サーバント} 
\section{サーバントとは}

   サーバントはハードウェアデバイス, サービスの登録簿(後述)、
   環境変数記憶、プロトコルスタックなど低位サービスを提供する。
   Plan9 のカーネルデバイスファイルシステム (Kernel device file systems)に相当する。
   サーバントはLP49-COREプロセス内のモジュールであり、
   attach(), init(), open(), read(), write(),,, といったプロシージャインタフェース
   で呼ばれる。

    システムは、ルート ("/") から始まる名前空間（Root file server）を持っている。
    各サーバやサーブレットも個別に名前空間 (directry tree) を持っており、
    各要素はパス名で指定される。
    サーバやサーブレットの名前空間を、自分の名前空間に"マウント" することに
    より、サービスにアクセスできるようになる。\\


\section{サーバントの種類}

     サーバント (内部サーバ) の一覧を表\ref{table:Servants}が示す。

\begin{comment}
\begin{verbatim}
      *----------------------------------------------------------
      |  #c    コンソール                                       
      |  #e    環境変数記憶簿                                   
      |  #l    Etherネットデバイス 
      |  #f    フロップーディスク                               
      |  #I    IPプロトコルインタフェース
      |  #X    ルップバックリンク                               
      |  #M    サーバマウントの機構                             
      |  #|    パイプ     
      |  #R    Rootファイルシステム                             
      |  #S    ストレッジデバイス                               
      |  #s    サーバ登録簿 (Server registray)                  
      |  #U    USBホストコントローラ                            
      |  #v    VGAコントローラ                                  
      *---------------------------------------------------------
\end{verbatim}      
\end{comment}


\begin{table}[htb]
\caption[Servants]{サーバント}
\label{table:Servants}
\begin{center}
{\small 
\begin{tabular}{|l|l|l|}
\hline
 サーバント名  &   機能    &   補足説明 \\
\hline
      \#c    &    コンソール             &  /dev/cons \\
      \#e    &    環境変数               & /env \\
      \#l    &    Etherネットデバイス    & \\
      \#f    &    フロッピーディスク     & \\                      
      \#I    &    IPプロトコル           & /net \\
      \#p    &    procファイル           & /proc \\
      \#X    &    ループバックリンク         & \\
      \#M    &    Remote Procedure Call      & /mnt, サーバをマウントする機構 \\
      \verb:#|:  &  パイプ                   &  \\
      \#R    &    Rootファイルシステム       & / (Plan9とは異なる)\\                  
      \#S    &    ストレッジデバイス                & /dev/sdC0, /dev/sdD0\\
      \#s    &    サーバ登録簿 (Server registry)    & /srv \\          
      \#U    &    USBホストコントローラ              & \\          
      \#v    &    VGAコントローラ                    & \\          
\hline
\end{tabular}
}
\end{center}
\end{table}

    
    
\section{サーバントの接続（バインド）}

   サーバントは、''bind コマンド''により、名前空間の指定マウントポイントに接続される。
   Unixでは同一のマウントポイントに複数を接続した場合、以前のものは隠されて
   最後の接続のみが有効になるが、
   Plan9/LP49 では同一のマウントポイントに複数を接続することができる。
   これを {\bf ユニオンマウント} と呼ぶ。
   ユニオンマウントの場合、同一の名前があれば前にあるものが見えるようになる。
   前に接続するか、後ろに接続するかは、bind/mountコマンドのオプションで指定する。
   \begin{description}
   \item[-a] ``after''を意味し、既存のものの後ろに接続される。 
   \item[-b] ``before''を意味し、既存のものの前に接続される。 
   \item[（無指定) ] 既存のものを置き換える。
   \end{description}

   また、 ``\verb|-c| ''オプションにより、
   Read-only で接続するか writable で接続するを指定できる。
   ``\verb|-C| ''オプションにより、
   Cache をするか否かを指定できる（まだ未実装）。

   \begin{description}
   \item[-c]  指定すればwritableになる。
   \item[-C]  指定すればcacheが有効化される（未実装）。
   \end{description}

\begin{verbatim}
    *-- << bind command >> ------------------------------------------             
    |  bind  [オプション]  サーバント名  マウントポイント  
    |
    |  オプション   (無)  置き換え                                
    |               -b    Before  (Cf. UNION mount)  
    |               -a    After                                   
    |               -c    書き込み許可  
    |
    |-- 【例】------------------------------------------------------
    | bind -a #f /dev                      
    *----------------------------------------------------------------
\end{verbatim}

      LP49のデバッグシェル qsh は、初期設定時に下記のコマンドを発行して各サーバントを
      所定位置に接続しているので、始めから各サーバントは名前空間に現れている。

\begin{verbatim} 
         bind  -a #c  /dev          ← コンソール 
         bind     #d  /fd           ← dupファイル記述し記録 
         bind  -c #e  /env          ← 環境変数記録簿
         bind  -c #s  /srv          ← サービス記録簿
         bind  -ac #R  /            ← Rootファイルシステム (後述)
         bind  -a  #f  /dev         ← フロッピー 
         bind  -a  #I0  /net        ← プロトコルスタック
         bind  -a  #l   /net        ← Etherデバイス
\end{verbatim}

      ここで、"/" に接続された \#R は RAMを使ったRoot ファイルシステム 
      (Cf. src/9/port/devrootfs.c )である。
      これを使えば、ハードディスクを用いずとも、/tmp の下でファイルをcreate, write, read できる。


%%%%
\chapter{サーバ}
\section{サーバとサーバリンク}

      サーバは、9P プロトコルを喋れるユーザモードのプロセスである。 
      9Pプロトコルは、TCP接続もしくは pipe を通して運ばれる。
      LP49の pipe は両方向通信である。勿論 pipe は、同一ノード内でしか使えない。
      サーバにつながれた TCP接続とpipeを合わせて「サーバリンク」と呼ぶことにする。
      サーバリンクにアクセスして 9Pプロトコルをやり取りすることで、サーバからサービスを受ける。
    サーバリンクを登録しておく仕組みが「サーバ登録簿」である。
    LP49は分散OSなので、サーバ登録簿にはローカルサーバもリモートサーバも登録される。

    サーバ登録簿は "\#s" という名前のサーバントであり (ソースプログラムは src/9/port/devsrv.c)、
    初期設定により名前空間の "/srv" に接続されている。
    サーバが登録されると "/srv/dos" (DOSファイルサーバ)、
    "/srv/ext2" (EXT2ファイルサーバ) のように名前空間に現れる。


\section{サーバ登録簿(/srv)}
      サーバは、起動されると以下のような手法で、サーバリンクを生成・登録する。\\

 {\bf (1) Pipe方式} \\

      サーバが  pipe サーバリンクを生成を生成して、
      その file descriptor を自ノードの ``/srv'' に登録する。

\begin{verbatim}
              *-----------*                         []----------*     
              |Service    |                          |  Server  |
              | registry  |                          |          |
              |           |      pipe                |          |
              | /srv/foo -|--------------------------|--        |            
              |           |                          |          |
              *-----------*                          *----------*             
\end{verbatim}


{\bf  (2) Announce, listen, accept方式と srvコマンド}\\

       サーバ側では、TCP のサービスポートを announce( ) して、
      サービス接続要求が来るのを listen( )している。
      クライアントからの接続要求に対し、
      受け入れ可能だったら accept() してサービスを提供する。

       クライアントマシン側では、"srv" コマンド (プートCDの /t/bin/srv ) を用いて、
       サーバに接続要求を送る。
       サーバ接続が成功すると、サーバリンク (TCP接続) が生成され、
       そのfile descriptorがサーバ登録簿に登録される。

\begin{verbatim}
      *- << srv command >> ------------------------------------------------
      |  /t/bin/srv [-abcC q] 　tcp!サーバマシン!サービス    サービス名   
      |
      |--【例】------------------------------------------------------------
      |    /t/bin/srv  -a tcp!10.0.0.1  u9fs  
      *--------------------------------------------------------------------

          *----------*                              []-----------*
          |Service   |                               |  Server   |    
          |registry  | srv command                   | announce()|  
          |        --|------------------------>      | listen()  |  
          | /srv/bar |===============================|  accept() |  
          |          |     TCP connection            |           |  
          *----------*                               *-----------*
\end{verbatim}


\section{名前空間へのマウント}

      「サーバ登録簿」のサービスを名前空間にマウントすることにより、
    ローカル・リモートを問わずに同等にアクセスできるようになる。

\begin{verbatim}
     *-- << mount command >> ---------------------------------------------------
     |      mount [オプション...]   パス名   マウントボイント   [位置指定]    
     |
     |〇オプション                                                            
     |        なし:  置き換える                                               
     |        -a:    after                                                    
     |        -b:    before                                                   
     |        -c:    create可能                                               
     |        -C:    Cache使用                                                
     |
     |〇パス名                                                                
     |     ex.  /srv/ramfs                                                    
     |
     |〇マウントポイント                                                      
     |     ex.  /work                                                         
     |
     |〇位置指定                                                              
     |      ファイルシステムのどのdirectoryに接続するかを指定。               
     |     ex.  /dev/sdC0/ext2-0    
     |
     |--【機能】----------------------------------------------------------
     | 「パス名」で指定された対象が、現名前空間の「マウントポイント」にマウントされる。
     |                                                                                 
     |--【例】------------------------------------------------------------
     |  mount  -a  /srv/u9fs   /n                                                      
     |  mount -ac  /srv/ext2  /work  ""                                                
     |  mount  -ac  /srv/ext2  /work   /dev/sdC0/ext2-0                                
     |                                                                                 
     *---------------------------------------------------------------------
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\part{ストレッジサービス}

\chapter{RAMファイルサーバの使い方}
\section{RAMファイルサーバの使い方(その1)}

      RAMファイルサーバは、引数無で起動すると 直接 ``/tmp'' にマウントされる。

\begin{verbatim}
   *-------------------------------------------------------------------
   | 1. RAMファイルサーバ RAMFS ( /t/bin/ramfs )を起動 (spawn) する          
   |    LP49[/]: spawn /t/bin/ramfs                                          
   |              ←  RAMFSプロセスが生成され、/tmp にマウントされる。        
   |                  引数 -D を付けると、9Pプロトコルのやりとりも出力される。
   |
   | 2. ファイルをつくってみる                                                
   |    LP49[/]: cd  /tmp                                                     
   |    LP49[/tmp]: create -w  zzz  0666                                      
   |              ←  FD が返る。ここでは 10 と仮定する。                      
   |    LP49[/tmp]: write  10  12345678901234567890                           
   |    LP49[/tmp]: pread  10  0                                              
   |      12345678901234567890                                                
   |    LP49[/tmp]: close  10                                                 
   |    LP49[/tmp]: mkdir  bb                                                 
   |    LP49[/tmp]: cp  zzz  bb                                               
   *------------------------------------------------------------------
\end{verbatim}


\section{RAMファイルサーバの使い方(その2  /srv )}

       RAMファイルサーバは、引数 "-S サービス名" を付けて起動すると、
       サービス記述簿 に ``/srv/サービス名''として登録される。 
       これを名前空間の適当な場所にマウントすることができる。

\begin{verbatim}
    *----------------------------------------------------------------
    | 1. RAMファイルサーバ RAMFS ( /t/bin/ramfs )を起動 (spawn) する   
    |    LP49[/]: spawn /t/bin/ramfs  -S ramfs                           
    |              ←  RAMFSプロセスが生成され、/srv/ramfs が登録される.
    |
    | 2. RAMファイルサーバ RAMFS を /work にマウントする               
    |    LP49[/]: mount -ac /srv/ramfs /work                           
    |               ←   RAMファイルサーバ が /work に表れる。          
    |
    | 3. ファイルをつくってみる                                        
    |    LP49[/]: cd  /work                                            
    |    LP49[/work]: create -w  zzz  0666                             
    |              ←  FD が返る。ここでは 10 と仮定する。              
    |    LP49[/]: write  10  12345678901234567890                      
    |    LP49[/]: pread  10  0                                         
    |      12345678901234567890                                        
    *----------------------------------------------------------------
\end{verbatim}

【図解】\\
\begin{verbatim}
                   []----------*                    []----------*    
                    |    APL   |                    |  RAMFS    |    
                    |          |                    |  server   |    
                    |    |     |                    |     |     |    
                    *----|-----*                    *-----| ----*    
                         |                          Pipe  |          
                   []----+--------------------------------+-----------*               
            CORE    |    |                                |           | 
          Process   | /work   <---------- /srv/ramfs      |           | 
                    |               mount      (Service registry)     |
                    *-------------------------------------------------*                  
\end{verbatim}   
  

%%%%
\chapter{ハードディスクの利用}

\section{ハードディスクドライバ}

      ATAハードディスクは、 ``\#S'' という名前を持ち、``/dev'' に接続して使用する。
\begin{comment}
    なお、「実マシン上で LP49 を動かしてみたいが、ハードディスクの内容を壊したくない」
    という場合には、ハードディスクドライバをはずしてコンパイルすればよい。
      src/pc/config-l4.c の中に、以下の定義がある。
    ここで、 \& sddevtab, をコメントアウトすれば、ハードディス
    クドライバは組み込まれない。

  \begin{verbatim}
      Dev  * devtab[ ] = {
            .......
           & sddevtab,     ← この行をコメントアウトればハードディスクドライバは除外される。
            ........
        }
  \end{verbatim}

  \section{LP49の名前空間とハードディスクの位置}
\end{comment}


 【手順】\\
\begin{verbatim}
    *---------------------------------------------------------------------------
    |  ◎ HDD は、次のコマンドで名前空間/devに接続する。                 
    |     LP49[/]  bind  -a  #S  /dev                                   
    |     ←    #S はハードディスクドライバを意味する                    
    |                                                                   
    |  ◎ ハードディスクは  /dev/sdC0  (あるいは  sdD0 ?) に現れる       
    |     ls  /dev/sdC0  を打ち込むと、例えば次のように表示される。     
    |     LP49[/] ls  /dev/sdC0                                         
    |     d r-xr-xr-x          0    sdC0/    ......                     
    |     this directory contains ...                                   
    |     - rw-r-----          0     ctl   .......    ← HDDの制御ファイル 
    |     x rw-------          0     raw   .......    ← HDDの生ファイル   
    |     - rw-r-----   ........     data  .......    ← HDD全体           
    |     - rw-r-----   .......      dos-0 .......    ← HDDのパーティション (DOSタイプ) 
    |     - rw-r-----   .......      ext2-0 .......   ← HDDのパーティション (ext2タイプ)
    *---------------------------------------------------------------------------
\end{verbatim}

\section{PC機のパーティションと LP49のパーティション}

{\bf (1) パーティション設定済みのハードディスクの場合}

       PC機では、ハードティスクの先頭512バイトに MBR (Master Boot Recorder)が載っており、
    MBRの後部に パーティションテーブルが載っている。

     \fbox{\parbox[c]{14cm}{ 
      (現時点) PC機のバーティションのうち、基本パーティションでタイプが dos, ext2,plan9  
       のものだけが、LP49 にも見える。\\       
      ● dosタイプのパーティションは、LP49 では /dev/sdC0 に dos-0, dos-1,,, という名前で見える    \\
      ● ext2タイプのパーティションは、LP49 では /dev/sdC0 に ext2-0, ext2-1,,, という名前で見える 
   　 }}


{\bf  (2) パーティション無設定のハードディスクの場合} 

       LP49 は、ハードディスクにパーティションが設定されていないと、src/9/pc/pcf-config-l4.c の  
\begin{verbatim}
           char __bootargs[2048] = 
              ......
             "sdC0part=dos 63 1000/plan9 1000 2000¥n"
             ..... ;
\end{verbatim}
       の内容に従って、LP49 のパーティションを設定する。
       ただし、ファイルシステムを構成しないと、DOS やEXT2ファイルサーバでは使うことができない。


\section{パーティションとファイルシステムの設定}

{\bf  (1) 実機の場合}

      \begin{description}
      \item[(方法 1)]   Partition Magic などのプログラムで設定する。

      \item[(方法 2)]  Linux をイストールすると、パーティションがつくられ
        EXT2ファイルシステムが設定れさる。

      \item[(方法 3)]   Windows をイストールすると、パーティションがつくられ
        DOSファイルシステムが設定れさる。
     \end{description}

{\bf (2) VMware の上で走らせる場合}

      \begin{description}
      \item[(方法 1)]    Partition Magic などのプログラムで設定する。

      \item[(方法 2)]   Linux をイストールすると、パーティションがつくられ
                   EXT2ファイルシステムが設定れさる。
                   但し、インストールのときに Linuxではなく『その他』としておかないと、
                   誤動作する?

      \item[(方法 3)]    Windows をイストールすると、パーティションがつくられ
                   DOSファイルシステムが設定れさる。
                   但し、インストールのときに Windowsではなく『その他』としておかないと、
                   誤動作する?
      \end{description}
    

%%%%
\chapter{EXT2ファイルサーバーの利用}

{\bf 【起動法】}
\begin{verbatim}
   *-------------------------------------------------
   | 1. EXT2パーティションを持つハードディスクを接続する。(既に接続されていれば、本コマンドは不要)  
   |    LP49[/]: bind  -a  #S  /dev                                                                 
   |    ==> ハードディスが /dev/sdC0  (あるいは sdD0 ?) に見えるようになる
   |
   | 2. EXT2ファイルサーバを起動する                                                                
   |    LP49[/]: spawn  /t/bin/ext2srv                                                              
   |      ==> EXT2ファイルサーバが起動され、サービス記録簿 /srv に /srv/ext2 が登録される。         
   |    オプション     -D :  9P プロトコルの内容を印字。 9Pプロトコルのやり取りが見えて面白い。     
   |                   -v :  デバッグ情報を印字                                                     
   |                   -r :  Read Only 
   |
   | 3. EXT2ファイルサーバ(/srv/ext2) を例えば名前空間の /work にマウントする。                     
   |    LP49[/]: mount  -c  /srv/ext2  /work  /dev/sdC0/ext2-0                                      
   |    ==>ハードディスクのEXT2パーティション  /dev/sdC0/ext2-0 が、/work にマウントされる。        
   |   
   | 4. EXT2ファイルシステムを使う。                                                                
   |    たとえば、Linuxがインストールされていれば、-------                                          
   |    LP49[/]: cd  /work/etc                                                                      
   |    LP49[/work/etc]: cat  hosts                                                                 
   |      127.0.0.0      localhost.localdomain  localhost                                           
   |    LP49[/work/etc]: cd /work/bin                                                               
   |    LP49[/work/bin]: open  -r  sort           ← Linux の /bin/ls ファイルをOpen                 
   |         FD が返される。ここでは 10 と仮定する。                                                
   |    LP49[/work/bin]: preadx  10  0  256       ← 先頭番地から 128バイトをダンプする。            
   |         バイナリ情報がダンプされる。                                                           
   |                                                                                                
   *-------------------------------------------------
\end{verbatim}  


%%%%  
\chapter{DOS ファイルサーバーの利用}

{\bf 【起動法】}
\begin{verbatim}
   *------------------------------------------------
   | 1. ハードディスクを接続する。(既に接続されていれば、本コマンドは不要)               
   |    LP49[/]: bind  -a  #S  /dev                                                      
   |    ==> ハードディスが /dev/sdC0  (あるいは sdD0 ?) に見えるようになる   
   |
   | 2. DOSファイルサーバは、既に立ち上がっており、 /srv/dos が見えるはず。              
   |    LP49[/]: ls   /srv                                                               
   |       d  r-xr-xr-x     0     srv/   ..........                                      
   |       this directory contains ....                                                  
   |       - rw-rw-rw       0     dos    .....                                           
   |
   | 3. DOSファイルサーバ(/srv/dos) を例えば名前空間の /work にマウントする。            
   |    LP49[/]: mount  -cc  /srv/dos  /work  /dev/sdC0/dos-0                            
   |    ==>ハードディスクのDOSパーティション  /dev/sdC0/dos-0 が、/work にマウントされる。
   |
   | 4. DOSファイルシステムが/work の下に見えるようになる。    ←←   バグがあり。          
   |    LP49[/]: ls /work                                                                 
   |
   | 5. DOSファイルを書いてみる                                                           
   |    LP49[/]: cd  /work                                                                
   |    LP49[/work]: create  -w  z1 0666                                                  
   |       .... エラーメッセージを吐きながら FDの値を返す .....   ここでは FD=10 とする。 
   |    LP49[/work]: write  10   AAABBBCCCDDDEEEFFFGGGHHH                                 
   |    LP49[/work]: pread  10  0                                                         
   |       AAABBBCCCDDDEEEFFFGGGHHH                                                       
   |                                                                                     
   *------------------------------------------------
\end{verbatim}  

%%%%%   
\chapter{USBメモリの利用}

      USB は大変便利であるが、USB デバイスを使うためのプログラムは、簡単ではない。
    USB規格には、USB-1.0と USB-2.0の規格がある。
   また、ホストコントローラインタフェースとして OHCI と UHCI がある。
   このうち、、現 LP49 がサポートしているのは USB-1.0 の UHCI のみである。
   最近のパソコンは殆ど USB-2.0 がついているが、その場合でも USB-1.0 のハブを間にかませれば、
   使うことができる。

     ソースプログラム: src/9/pc/devusb.c、src/9/pc/usbuhci、src/cmd/usb/usbd/* 、src/cmd/usb/usbsfs/*  
  
{\bf 【起動法】}
\begin{verbatim}
   *-----------------------------------------------------------------------
   | 1. USB を接続する。(既に接続されていれば、本コマンドは不要)           
   |    LP49[/]: bind  -a  #U  /dev                                        
   |    ==> USB が /dev/usb0  (あるいは usb1 ?) に見えるようになる         
   |                                                                       
   | 2. USBデーモンを起動する。                                            
   |    LP49[/]: spawn  /t/bin/usbd                                        
   |    → "usbd"プロセスが生成される。                                     
   |                                                                       
   | 3. usbsfs プロセスを立ちあげる                                         
   |    LP49[/]: spawn  /t/bin/usbsfs                                      
   |    → "usbsfs"プロセスが生成され、"/ums" にマウントされる。            
   |        /ums/ctl, /ums/raw,  /ums/data などを確認できるはず。          
   |                                                                       
   | 4. DOS2ファイルサーバを立ちあげる                                     
   |    LP49[/]: spawn  /t/bin/dos2  -f  /ums/data:32  usbs                
   |    → "dos2"サーバが生成され、サーバ登録簿に /srv/dos2 が登録される。
   |                                                                       
   | 4. usbsfsをマウントする                                               
   |    LP49[/]: mount -ac  /srv/usbs   /work                              
   |    LP49[/]: ls  /work                                                 
   *-------------------------------------------------------------
\end{verbatim}                                           


%%%%%
%\chapter{ Linuxファイルのマウント}
%
%     ネットワークを介して Linux のファイルシステムを LP49 にマウントすることも可能である
%     (Plan9 で開発された U9FS の移植)。
%      この機能については、ネットワークの部で説明する。   


%%%%%%%%%%%%%%%%%%%%
% \newpage
\part{ネットワークサービス}

\chapter{マシン環境の設定}

      LP49 は、実機、Qemu エミュレータ、 VMware 仮想マシンなどで走らせることができる。


{\bf (1) 現在の所、下記の Etherカードが利用可能である}

        * AMD79c970 (Lance)    

        * NE2000 

        * Realtek 8139, 8168

        * DEC2114

        * Intel82557
\\

{\bf  (2) LP49 は、自動的に probing して Etherカードを判別して適切なドライバを選択する}
\\

{\bf  (3) IPアドレスと Gateway アドレスの設定は、ipsetコマンドを使う}

\begin{verbatim}
        *---------------------------------------------------*      
        | LP49[/]: ipsetup <IPaddress>  <GatewayAddress>    |
        *---------------------------------------------------*           
\end{verbatim}

%%%
\chapter{QEMUゲストオンリーNW(LP49-LP49通信)の設定}

{\bf (1) 位置づけ}

        ホストOS上では、ゲスト OS (LP49) の ネットワークは TUPインタフェースとして現れる。

\begin{comment}
{\small
\begin{verbatim}
       *----- Host computer ---------------------*
       |                                         |      
       |  *- Guest OS --*     *- Guest OS---+    |       
       |  |             |     |             |    | 
       |  |    LP49     |     |    LP49     |    | 
       |  |             |     |             |    | 
       |  |-------------|     |-------------|    |                   
       |  |   Qemu      |     |   Qemu      |    | 
       |  *-------|-----*     *------|------*    |
       |          -------------------            |             
       |       (10.0.0.2)    (Ex. 10.0.0.5)      | 
       *-----------------------------------------*
\end{verbatim}
}    
\end{comment}


\begin{figure}[hb]
\begin{center}
\setlength{\unitlength}{0.6mm}
\begin{picture}(120, 70)
  \put(10,0){\framebox(100, 60)[tc]{Host computer}}
  \put(15,5){\makebox(40, 10)[l]{(10:0:0:2)}}
  \put(15,15){\framebox(40, 10)[c]{Qemu}}
  \put(15,25){\framebox(40, 25)[c]{Guest OS: LP49}}
  \put(65,5){\makebox(40, 10)[r]{(10:0:0:5)}}
  \put(65,15){\framebox(40, 10)[c]{Qemu}}
  \put(65,25){\framebox(40, 25)[c]{Guest OS: LP49}}
  \put(40,8){\line(1,0){40}}
  \put(40,8){\line(0,1){7}}
  \put(80,8){\line(0,1){7}}
\end{picture}
\end{center}
\caption{LP49 間通信}
\end{figure}



{\bf (2) LP49-1  の起動}

          LP49 ディレクトリにブートCD/FDイメージ (lp49-boot.cd, lp49-boot-x2.fd)があるものとする。


{\bf  (2-1) QEMUの起動}

\begin{verbatim}
         +----------------------------------------------------------------------
         |  # cd  LP49                                                                         
         |  # qemu -cdrom  lp49-boot.cd  -std-vga -net nic -net socket,listen=localhost:1234   
         |       ←  CDイメージから立ち上げる場合                                               
         |           フロッピーイメージから立ち上げる場合は、『-fda lp49-boot-x2.fd』を指定する。
         +-----------------------------------------------------------------------
\end{verbatim}


{\bf (2-2) LP49が立ち上がったら、IPアドレスを設定する}\\

\begin{verbatim}
     *------------------------------------------------------------------------
     |  LP49[/]: ipsetup                                                                       
     |     引数を指定しないと、IPアドレス: 10.0.0.2、 Gatewayアドレス: 10.0.0.1 に設定される。 
     *-------------------------------------------------------------------------
\end{verbatim}

    
{\bf (3) LP49-2  の起動}


{\bf  (3-1) QEMUの起動}

\begin{verbatim}
     *----------------------------------------------------------------------------------
     |  # cd  LP49                                                                 
     |  # qemu -cdrom lp49-boot.cd  -std-vga -net nic,macadds=52:54:00:12:34:57 ¥  
     |         -net socket,connect=localhost:1234                                  
     |       ←  CDイメージから立ち上げる場合                                       
     |           フロッピーイメージから立ち上げる場合は、『-fda lp49-boot-x2.fd』を指定する。
     *----------------------------------------------------------------------------------
\end{verbatim}

{\bf (3-2) LP49が立ち上がったら、IPアドレスを設定する}\\
\begin{verbatim}
     *--------------------------------------------------------------------
     |  LP49[/]: ipsetup 10.0.0.5                                 
     |    Gatewayアドレス を省略すると10.0.0.1 に設定される       
     *--------------------------------------------------------------------
\end{verbatim}
     
{\bf (4)  ping の実験}

       例えば LP49-1 から LP49-2 に ping を行なう。
\begin{verbatim}
     *---------------------------------------------*    
     |  LP49[/]: /t/bin/ping  10.0.0.5             |    
     *---------------------------------------------*    
\end{verbatim}

    
{\bf  (5) exportfs, import  の実験}

       例えば LP49-1 の名前空間を  LP49-2 にマウントする。
\begin{verbatim}
      *-- <<LP49-1>> -----------------------------------------* 
      |  LP49[/]: /t/bin/listen1 tcp!*!55 /t/bin/exportfs &   | 
      *-------------------------------------------------------* 
\end{verbatim}

   これにより、ノード LP49-1 は、任意のノードからTCPのポート55番 (tcp!*!55) への要求を監視し、
   この要求がきたらプロセスを生成して /t/bin/exportfs (名前環境をexportするサーバ) を実行させる。

\begin{verbatim}    
      *-- << LP49-2 >> ---------------------------------------
      |  LP49[/]: /t/bin/import -a 10.0.0.2   /t  /n       
      |  LP49[/]: cd   /n      ← /n に相手マシンの /t 以下の名前空間が見えるようになる。
      *-------------------------------------------------------
\end{verbatim}

         これにより、ノード LP49-2 は、IPアドレス= 10.0.0.2 の名前空間 /t を自分の名前空間の /nに
         マウントする。"-a" はユニオンマウントの after を意味する。
         /n 以下を覗けば、相手マシンの /t 以下をみることができる。



%%%%
\chapter{TUN/TAPを使ったQEMU(LP49-ホストOS通信)の設定}
 
{\bf (1) 位置づけ}

        ホストOS上では、ゲスト OS (LP49) の ネットワークは TUPインタフェースとして現れる。

%\begin{comment}
\begin{figure}
\begin{center}
\setlength{\unitlength}{0.6mm}
\begin{picture}(120, 70)
  \put(10,0){\framebox(100, 60)[tc]{Host computer}}
  \put(15,5){\makebox(40, 10)[l]{(10:0:0:2)}}
  \put(15,15){\framebox(40, 10)[c]{Qemu}}
  \put(15,25){\framebox(40, 25)[c]{Guest OS: LP49}}
  \put(65,5){\makebox(40, 10)[r]{(10:0:0:1)}}
  \put(65,15){\framebox(40, 35)[c]{Host OS}}
  \put(40,8){\line(1,0){40}}
  \put(40,8){\line(0,1){7}}
  \put(80,8){\line(0,1){7}}
\end{picture}
\end{center}
\caption{LP49-Linux間通信}
\end{figure}
%\end{comment}
    
{\bf (2) ホスト OS 側の設定}

{\bf  (2-1) TUNモジュールをインストール}

\begin{verbatim}
       *-----------------------------------------------*                               
       |  # ls  -l  /dev/net/tun                       |        
       |  # chmod  0660  /dev/net/tun                  |        
       |  # chgrp   maruyama  /dev/net/tun             |        
       |  # modprobe  tun                              |        
       *-----------------------------------------------*                               
\end{verbatim}

{\bf  (2-2) "/etc/qemu-ifup" スクリプトを設定する}\\

\begin{verbatim}
       *--------- /etc/qemu-ifup -----------------------*
       | #!/bin/sh                                      |
       | sudo  /sbin/ifconfig  "\$1"  10.0.0.1          |
       *------------------------------------------------*
\end{verbatim}

{\bf  (2-3) "qemu-ifup" を実行できるよう、"visudo"コマンドを用いて "/etc/sudoers" ファイルに以下を追加}\\

\begin{verbatim}
        *------/etc/sudoers---------------------------*                          
        | maruyama    ALL=(ALL)  ALL                  |           
        *---------------------------------------------*                                
\end{verbatim}

{\bf (3)  Qemuコマンドにより、LP49 を走らせる}

\begin{verbatim}
       *---------------------------------------------------------------------------------*
       | # sudo  qemu  -fda  /home/maruyama/LP49/lp49-bootfd-x2.fd  -net nic  -net tap   |
       | password:   <your-password>                                                     |
       *---------------------------------------------------------------------------------* 
\end{verbatim}

{\bf (4)  LP49上で、"ipsetup" コマンドにより IPアドレスと Gatewayアドレスを設定する}

        IPアドレスと Gatewayアドレスを省略すると、(qemuに便利なように) 10.0.0.2 と
         10.0.0.1 が設定される。

\begin{verbatim}
       *-----------------------------------------------------------*
       | LP49[/] ipsetup <IPaddress>  <GatewayAddress>             |
       +-- Ex.-----------------------------------------------------*
       | LP49[/] ipsetup  10.0.0.2  10.0.0.1                       |
       |    LP49[/] ipsetup                                        |
       *-----------------------------------------------------------*
\end{verbatim}


\chapter{VMwareの場合の設定}

{\bf (1) VMware のプライベットアドレスを調べる}

\begin{verbatim}  
        *---------------------------------------------------------------------------------*
        |  [Linux] /sbin/ifconfig                                                         |
        |  lo        Link encap:Local Loopback                                            |
        |            inet addr:127.0.0.1  Mask:255.0.0.0                                  |
        |            .............                                                        |
        |                                                                                 |
        |  vmnet1    Link encap:Ethernet  HWaddr 00:50:56:C0:00:01                        |
        |            inet addr:192.168.74.1  Bcast:192.168.74.255  Mask:255.255.255.0     |
        |            ........................                                             |
        |                                                                                 |
        |  ==>  Private NW       192.168.74.0/24                                          |
        |       Gateway address  192.168.74.1                                             |
        *---------------------------------------------------------------------------------* 
\end{verbatim}  

{\bf (2) IPアドレスとGateway アドレスを設定する}

\begin{verbatim}  
       *--------------------------------------------------------------------------*  
       | LP49[/]: ipsetup  <IPaddress>  <GatewayAddress>                          |         
       +--Ex. --------------------------------------------------------------------+ 
       | LP49[/]: ipsetup  192.168.74.2  192.168.74.1                             | 
       *--------------------------------------------------------------------------*  
\end{verbatim}  


    
\chapter{サーバ登録簿}

      LP49 では、サーバはサーバ登録簿 (\verb|/src/*|) に登録されて、利用可能になる。
      サーバ登録簿については、第1部      を参照のこと。

    
\chapter{離れたマシンの名前空間をマウントする}

   別のマシンの名前空間の任意のサブトリーを自分の名前空間のマウントボイントにマウントすることにより、 
   別マシンのサブトリーにアクセスすることが可能にくなる。
    Plan9/LP49 ではデバイスを含めて全てのリソースはファイルシステムとして抽象化されているので、
    離れたマシンのデバイスも制御できる。

    指定された名前空間へのアクセスの可否は、認証サービスの役目である。
   LP49 では認証サービスは未実装である。

\begin{comment}
\begin{figure}
\begin{center}
\setlength{\unitlength}{0.6mm}
\begin{picture}(140, 70)
  \put(10,0){\framebox(50, 60)[tc]{LP49: Import side}}
  \put(10,40){\makebox(50, 10)[tc]{Name Space}}
  \put(80,0){\framebox(50, 60)[tc]{LP49: Export side}}
  \put(80,40){\makebox(50, 10)[tc]{Name Space}}
\end{picture}
\end{center}
\caption{名前空間のexport/import}
\end{figure}
\end{comment}
    

\begin{figure}[htb]
  \begin{center}
   \epsfxsize=440pt
   \epsfbox{fig/NSmount.eps}
    \caption{名前空間とマウント}
    \label{fig:NSmount}
  \end{center}
\end{figure}



\section{Export側の設定}

\begin{verbatim}    
   *-------------------------------------------------------------------
   | 1. # cd LP49                                                                        
   |
   | 2. # qemu -cdrom lp49-boot.cd -std-vga -net nic -net socket,listen=localhost:1234   
   |
   | 3. LP49を立ち上げる
   |
   | 4. LP49[/]: ipsetup                                                                 
   |    IP address is set to default value: 10.0.0.2                                     
   |
   | 5. LP49[/]: t/bin/listen1 tcp!*!55 /t/bin/exportfs &                                
   |    これにより、TCP 55番ポートに要求がきたら、/t/bin/exportfs プロセスが起動される。 
   |
   | 6. もし、9Pプロトコルのやりとりを観察したいなら、-d を指定する。                    
   |    LP49[/]: t/bin/listen1 tcp!*!55 /t/bin/exportfs -d &                             
   |    -d を付けると、9Pプロトコルのやりとりが印字される。                              
   *--------------------------------------------------------------------
\end{verbatim}    
    
\section{Import側の設定}

\begin{verbatim}        
     *----------------------------------------------------------------------------
     | 1. # cd LP49                                                                      
     |
     | 2. # qemu -cdrom lp49-boot.cd -std-vga -net nic,macaddr=52:54:00:12:34:57 ¥       
     |            -net socket,connect=localhost:1234                                     
     | 3. LP49を立ち上げる      
     |
     | 4. LP49[/]: ipsetup 10.0.0.5                                                      
     |    IP address is set to the specified value: 10.0.0.5                             
     |
     | 5. LP49[/]: t/bin/import -a 10.0.0.2 /t /n                                        
     |    これは、マシン 10.0.0.5 のディレクトリー /t 以下の名前空間を
     |    自マシンのィレクトリー /n にマウントすることを要求している。
     |     
     | 6. LP49[/]: cd /n                                                                
     |    /nにexportマシンの名前空間 /t が見えるようになる。                            
     |
     | 7. LP49[/n]: ls                                                                  
     |
     | 8. LP49[/n]: cd bin                                                              
     |
     | 9. LP49[/n/bin]: ex2                                                             
     |    exportマシンの /t/bin/ex2 が実行される。                                      
     |
     | 10.LP49[/n/bin]: cd                                                              
     |
     | 11.LP49[/n/bin]: unmount  /n                                                     
     *------------------------------------------------------------------------------
\end{verbatim}   
    

\chapter{U9FS: LinuxのファイルトリーをLP49マウントする}

      U9FSは、Linux のファイルトリーを LP49 の名前空間にマウントして、
      Linux上のファイルをアクセスする機能である。
      Plan9 の u9fs を LP49 への移植である。
    

\section{Qemu・VMwawe 上のLP49にホストOSのファイルをマウントする例}
\begin{comment}    
       *---------  Linux -------------------*          
       | -*--- LP49 ------*     Linux-file-tree     |  
       |  |               |                         |  
       |  |     /dev/      |                        |  
       |  |    /n ------ - |--------  /aa/          |  
       |  |                |                bb/     |  
       |  |                |                     b1 |  
       |  |    LP49        |                     b2 |  
       |  |                |                cc/     |  
       |  |                |                     c1 |  
       |  |                |                dd/     |  
       | -*------------*                            |  
       *--------------------------------*              

\begin{figure}
\begin{center}
\setlength{\unitlength}{1mm}
\begin{picture}(140, 70)
  \put(10,0){\framebox(50, 60)[tc]{LP49: Import side}}
  \put(10,40){\makebox(50, 10)[tc]{Name Space}}
  \put(80,0){\framebox(50, 60)[tc]{Linux Host OS}}
  \put(80,40){\makebox(50, 10)[tc]{Name Space}}
\end{picture}
\end{center}
\caption{LinuxのファイルシステムをLP49にマウント}
\end{figure}

\end{comment}    

    
\section{Linux側の設定}

        Linux側では、"u9fs" プログラムが走るように設定する。
\begin{enumerate}
\item      実行ファイル "u9fs"  (LP49-yymmdd/src/cmd/unix/u9fs/u9fs に入っている) を
            "/usr/local/etc" にインストールする。\\
\begin{verbatim}    
         *---------------------------------------------------------------------* 
         | [Linux]: cp LP49-yymmdd/src/cmd/unix/u9fs/u9fs /usr/local/etc       |
         *---------------------------------------------------------------------*
\end{verbatim}    

\item    "/etc/services" に下記行を追加する\\
\begin{verbatim}    
         *-------------------------------------------------------*    
         | u9fs      564/tcp                                     | 
         *-------------------------------------------------------*
\end{verbatim}    

\item 以下を内容とするファイル "u9fs" を "/etc/xinetd.d/" に設ける。\\

\begin{verbatim}    
          *-----------------------------------------------------------*                      
          |   service u9fs                                            |
          |   {                                                       |
          |     disable         = no                                  |
          |     socket_type     = stream                              |
          |     protocol        = tcp                                 |
          |     user            = root                                |
          |     wait            = no                                  |
          |     user            = root                                |
          |     server          = /usr/local/etc/u9fs                 |
          |     server_args     = -Dz -a none -u maruyama /home/      |
          |     groups          = yes                                 |
          |     flags           = REUSE                               |
          |   }                                                       |
          |                                                           |
          *-----------------------------------------------------------*
            ここに"server_args" は 以下を意味する。                  
                                                                     
            -Dz : デバッグデータの置き場所   "/tmp/u9fs.log"         
                                                                     
            -a none : No authentification.                           
                                                                     
            -u <username>  ; /home/<username>                        
                                                                     
            /home/ :  File trees from /home/ are mounted.            

\end{verbatim}    

\item  Firewall の tcp/564ボートを空ける。\\

         (FedoreCore の Firewall 設定には、結構苦心した)

\item   xinetd をリスタートする\\

\begin{verbatim}   
          *---------------------------------------------*                             
          |  % /etc/init.d/xinetd  restart              |                         
          *---------------------------------------------*                             
\end{verbatim}    
\end{enumerate}


\section{LP49 側の設定}

      LP49では、"srv" コマンドを使って、Linux上の u9fs サーバへのサーバリンクをえる。
      "srv"コマンドは、ブートフロッピーに " b/srv" として載せてある。

\begin{enumerate}
\item  LP49 を起動する\\

\item IPアドレスと Gateway ヲドレスを設定する。\\

\begin{verbatim}    
      *---------------------------------------------------------------*  
      |  LP49[/]; ipsetup  <IPaddress>  <GateWayAddress>              | 
      |-【例】--------------------------------------------------------+  
      |  Ex.  ipsetup 10.0.0.2  10.0.0.1                              | 
      *---------------------------------------------------------------* 
\end{verbatim}    

\item "srv"コマンド (ブートフロッピーの b/srv )を実行する。\\

\begin{verbatim}    
      *----------------------------------------------------------*
      |  LP49[/]; spawn  /t/bin/srv  tcp!10.0.0.1  u9fs            |
      *----------------------------------------------------------*
\end{verbatim}    

       これにより、目的サーバの u9fs に対してTCPコネクションが張られ、
       サーバ登録簿に "/srv/u9fs" が登録される。


\item  サービスを名前空間の "/n"にマウントする。\\

\begin{verbatim}    
         *-------------------------------------------------------------* 
         | LP49[/]; mount -a /srv/u9fs  /n                             |  
         | LP49[/]: cd  /n                                             |  
         | LP49[/n]: ls                                                |  
         *-------------------------------------------------------------* 
\end{verbatim}    

\item "/n" の下ニ、Linux のファイルトリーが現れる.\\

\item  仕事が終了したら、unmount する.\\

\begin{verbatim}
         *-------------------------------------------------------------* 
         | LP49[/n]; cd /                                              |  
         | LP49[/]: unmount  /n                                        |  
         *-------------------------------------------------------------*  
\end{verbatim}    
\end{enumerate}


%%%%%%%%%%%%
%\newpage
\part{qshシェルとrcシェル}

\chapter{QSHシェル}

\section{QSHシェルとは}

      qsh シェルは、LP49 のデバッグのために作った (dirtyな) 簡易シェルであり、
      多くのシステムコールをコマンドレベルで試すことができるようになっている。
      本格的シェルとしては、Plan9 の "rc" シェルを移植中であり、
    これは qsh の中から起動できる。
      qsh は、以下のシーケンスで起動される。ブートフロッピー上のファイルを使うために、
      DOSファイルサーバも起動している。

\begin{verbatim}
       HVM process                             Cf. src/9/hvm
          -->  PC process  (core process)      Cf. src/9/{pc, port, ip}
               -->  QSH process                Cf. src/9/qsh
               --> DOSSRV process         Cf. src/cmd/dossrv
\end{verbatim}      

      qsh は、初期設定として以下の名前空間を作り、サーバント(拡張デバイス)などを接続する

\begin{verbatim}
        *-----------------------------------------------------------------
        |    /dev       デバイス (#c=console, #f=floppy,,,) を接続する     
        |    /env       環境変数 (#e)                                      
        |    /srv       サーバ登録簿 (#s)                                
        |    /          RAMファイルサーバント (#R) を接続                  
        |    /net       Protocol stack(#I), EtherDriver(#l)                
        |    /t         ブートフロッピーイメージをマウント                 
        *----------------------------------------------------------------
\end{verbatim}    
    
    ファイルサービスとしては、"/t" にブートフロピーが、
    "/" に RAMファイルサーバントがマウントされており、
    ハードディスクを使わずともファイル機能を試すことができる。

    (a) "/t" にはブートフロピーをマウントされている

{\small
\begin{verbatim}
    -- / -- t/ --+- boot/ - -+ grub/ --menu.lst
                 |           |-- hvm,gz   : Hypervisor process (only name)
                 |           |- pc.gz    : LP49 core process (user mode, off course)
                 |           |- qsh.gz   : Quasi shell (Shell for debugging)
                 |           |- dossrv.gz : DOS file server  
                 |                                             
                 |--l4/  --|-kickstart-0804.gz  :  L4 startup 
                 |         |-l4ka-0804.gz       :  L4 micro kernel
                 |         |-sigma0-0805.gz     :  L4 sigma0 pager
                 |                                             
                 |                                             
                 |- bin/ --|- cmd.zip  : zip files containing several commands
                           |- srv      : srv command
                           |- ex2      : program example
                           |- rc       : Shell ported from Plan9
                                  :
                                  :
\end{verbatim}
}

    (b) "/" に ROOTファイルサーバント\#R (cf. src/9/port/devrootfs.c) がマウントされている
           

%%%
\section{QSHの組込みコマンド(その1: 通常コマンド)}

\begin{verbatim}
    〇 help
    
    〇 unzip -f <zipfile>  
       Ex.  cd  /usr
            unzip -f /t/bin/cmd.zip    --- Now, you can see several copmmands on /tmp.
    
    〇  tar [cxt][vo][F][f] <tarfile> [<files>...] 
         -- Not yet implemented
    
    〇  ls  [ <path> ]     show the list of <path> directory 
    〇  lc  [ <path> ]     short verion of ls
    
    〇  cd  [ <path> ]     changes working directory to <path>
    〇  pwd                show the current working directory
    
    〇  echo  <any_string>   echo back any-string 
    
    〇  cat <path>         displays contents of the file <path>
    
    〇  remove  <name>     Delete a file         Not-Yet-Implemented
    
    〇  mkdir <dirname>     make a new directory
    
    〇  fd2path  <fd> <buf> <len>   Not yet implemented
    
    〇  bind [-abcC]  <#newpath>  <mountpoint>
        -a after
        -b before
        -c allow creattion    -ac, -bc 
         Ex.  bind -a #l  /net
              bind -a #SsdC0  /dev
    
    〇  mount [-abcC] <srvname> <mountpoint> <spec>
        -a after
        -b before
        -c allow creattion    -ac, -bc 
        -C
        Ex.   mount -c /srv/dos /tmp  /dev/fd0ctl
    
    〇  unmount  [<name>] <mntpoint>  
    
    〇  putenv  <name>  <value>
    〇  getenv  <name> 
    
    〇  rfork     
    〇  fork  [<pathname>]
    〇  exec  <pathname>
    〇  exits <msg>
    
    〇  spawn  <pathname>  <parameters>....
    〇  <pathname>  <parameters>....
        --- Spawn a new process
    
    〇 ipsetup  [<IPaddress>  <GatewayAddress>]     
        -- Setup the IPaddress and GatewayAddress.
        -- Default is:   10.0.0.2  10.0.0.1
    
    〇 usbsetup
         -- Setyup the USB memory 
    
    〇 partition
         -- Get the partition table contents
    
    【お遊び】
    〇  d  vga           マンデルブロー図
    〇  SL
    〇  pi                pi-value
    〇  credits          Contributors 
\end{verbatim}   



\section{QSHの組込みコマンド(その2: ファイルサービステスト)}

   Qshはデバッグ用シェルなので、以下のコマンドも組み込んでいる。

\begin{verbatim}   
    〇  create  [-rwWxc]  <name>  <permission>
    
    〇  open    [-rwWxtcde] <name> <mode> 
        -r Read
        -w Write
        -x Executable 
        ....	
    
    〇  close  <fd>
    
    〇  seek  {fd>  <offset>  <type>
    
    〇  write <fd> <any_string>

    〇  pwrite <fd> <offset> <any_string>
    
    〇  read <fd> 

    〇  pread  <fd> <offset>      

    〇  preadx <fd> <offset> [<size>]  
        show the contents in Hex and ascii of <fd> file 
    
    〇  pipe

    〇  dup <oldfd> <newfd>
    
    〇  put <txt>          _write <text>

    〇  putsl              _write $sl 

    〇  get                displays contents _written
    
    〇  give <txt>          _write <text>

    〇  givesl              _write $sl

    〇  take                displays contents _written

    〇  maptest <size>     Test L4 fpage mapping

    〇  pgmap  <procnr> 

    〇  pgmap  <procnr> <adrs> <len>
\end{verbatim}   
    

\section{QSHの組込みコマンド(その3: デバッグダンプ)}

\begin{verbatim}   
    〇  kd                  Enter into the L4 kernel bebugger

    〇  dump <process-nr> <start-adrs> <size>      Memory dump  
    
    ◯   qsh は、デバッグダンプ機能として "d" コマンドをもっている。
        *-------------------------------*
        |    d  <table> <parameter>     |
        *-------------------------------*

    〇  d  chan <Chan-adrs> 

    〇  d  ch  <Chan-fid> 

    〇  d  namec <path-name>       Dump the chan denoted by <path-name>

    〇  d  dev   <Dev-adrs> 

    〇  d  mount <mount-adrs>  

    〇  d  mhead  <Mhead-adrs> 	

    〇  d  mnt	<Mnt-adrs> 

    〇  d  pgrp  <Pgrp-adrs> 

    〇  d  fgrp  <Fgrp-adrs> 

    〇  d  proc  <Proc-adrs>  

    〇  d  up                     Dump the current Proc-table

    〇  d  ns                     Dump the current name space (Mhead, Mount,,,,) 

    〇  d  nss                    dumpmount() in  port/chan.c 

    〇  d dirtab  <Dirtab-adrs> 

    〇  d walkqid  <Walkqid-adrs>  
\end{verbatim}   



\chapter{RCシェル}

      rc シェルは、Plan9 rcシェルであり、大変強力な機能をもっている。
     現在 LP49 への移植を進めているところであり、部分的に動作する。
      rc シェルは、ブートフロッピーイメージ lp49-boot-x2.fd に bin/rc に載せてあるので、
     qshから以下のようにして起動できる。\\

     \verb|   LP49:[/]: /t/bin/rc   |
    
      path変数は "(. /t/bin /bin)" に設定してあるので、プログラムサーチは現ディレクトリ, 
     /t/bin, /bin の順でおこなう。\\


【メモ】 "rc" はコマンドのシンタックス分析にyacc を使っているが、 
          Unixのyacc がshort int を返すところを、
          Plan9 のyaccは int を返す(Unicode対応?)。
         この違いに気がつくのが遅れ、時間をロスした。   


%%%%%%%%%%%%
\newpage
\part{Makeの方法}

\chapter{Makeの仕方}  
\section{ LP49 tar ファイル}

      "LP49-yymmdd.tar" ファイルは、http://research.nii.ac.jp/H2O/LP49 からダウンロードしてください。

{\bf 【Tarファイル内のディレクトリ構造】}\\

{\footnotesize
\begin{verbatim}
     *------------------------------------------------------------------------- 
     |  LP49-yymmdd/                                                           |
     |              doc/                                                       |
     |              include/                                                   |
     |              lib/      --- symbolic links to libxxx.a files             |
     |              rootfs/                                                    |
     |                      bin/    --- LP49 command files                     |
     |                              Makefile    -- build cmd.zip               |
     |                              cmd.zip                                    |
     |                              ....        -- command files               |
     |                      boot/   --- LP49                                   |
     |                              hvm.gz                                     |
     |                              pc.gz                                      |
     |                              qsh.gz                                     |
     |                              dossrv.gz                                  |
     |                      l4/                                                |
     |                              kickstart.gz                               |
     |                              l4ka.gz                                    |
     |                              sigma0.gz                                  |
     |                                                                         |
     |              src/     --- Source files                                  |
     |                      Makefie  --- just "make clean; make"               |
     |                      Maketool                                           |
     |                      9/                                                 |
     |                              hvm/                                       |
     |                              pc/                                        |
     |                              port/                                      |
     |                              ip/                                        |
     |                              qsh/                                       |
     |                                                                         |
     |                      cmd/  --- Command source files                     |
     |                              ext2fs/                                    |
     |                              ....                                       |
     |                              simple/                                    |
     |                              test/                                      |
     |                              usb/                                       |
     |                                                                         |
     |                      lib*/                                              |
     *-------------------------------------------------------------------------   
\end{verbatim}        
}

\section{Make} 

{\bf (1) Makefile}\\  
      Makefile の定義は、大きな抜けがあります (手が回らない)。
      特に ヘッダファイル (*.h) の更新に対しては無対処です。
      ヘッダファイルを修正した場合は、make clean してから  make してください。
    
    
{\bf  (2) システム全部の make}\\

\begin{enumerate}
\item Chnge dir onto  LP49-yymmdd/src/ directory\\

        % cd  LP49-yymmdd/src/ 

\item Clean up  \\

        % make clean

\item Then  make \\

        %  make   \\

        Many warnings... 

\item  構築されたバイナリを、 "LP49-yymmdd/rootfs/{boot, bin}/"ディレクトリにコピーする。\\

         % make install \\
         
         LP49-yymmdd/rootfs/boot/*   には、OS本体が \\ 

         LP49-yymmdd/rootfs/bin/*    にはコマンド類がコピーされる。

\item  Linuxのmkisofsコマンドを使ってrootfs/ から  CD ブートファイルイメージを作る \\

    LP49-yymmdd/mkcd   を参照  \\
   \begin{verbatim}
   [Linux]  mkisofs -R -b boot/grub/stage2_eltorito -no-emul-boot \
         -boot-load-size 4 -boot-info-table -o ../lp49-boot.cd  rootfs
   \end{verbatim}

\end{enumerate}


\section{ブートCD、ブートフロッピーのイメージファイル}

      lp49-boot.fd : 1.44 MB floppy image

      lp49-boot-x2.fd :  2.88 MB floppy image
    
    (1) 内容

\begin{verbatim}
    lp49-boot.cd:
            l4/
                    kickstart-0804.gz    --- L4 kernel startup  
                    l4ka-0804.gz         --- L4 micro kernel
                    sigma0-0804.gz       --- L4 root pager
            boot/      
                    dossrv.gz    --- DOS file server
                    hvm.gz       --- (not) Hypervisory module
                    pc.gz        --- LP49 core process
                    qsh.gz       --- LP49 quasi (debugging) shell
                    grub/
                            menu.lst  --- Grub menu
                            stage1    --- Grub stage-1
                            stage2    --- Grub stage-2
            bin/       
                    cmd.zip    ---- ZIP file of LP49 commands.
                    各コマンド
\end{verbatim}    
    
    (2) When LP49 startup, boot file is mounted at the /t directory. \\
         LP49[/]: ls /t


\section{デバグ支援}


{\bf  (1)  LP49/include/l4/\_dbgpr.h ファイルは、デバッグ用機能を定義している。}

\begin{verbatim}
        extern int  l4printf_b(const char*, ...);
        extern char l4printgetc();
         
        #define  DBGPRN  if(_DBGFLG) l4printf_b
        #define  DBGBRK  if(_DBGFLG) l4printgetc
        #define  DD(x)   if(_DBGFLG) l4printf_b("%s: %x ¥n", __FUNCTION__, x);
         
        #define  DPR     l4printf_r
        #define  DPG     l4printf_g
        #define  DPB     l4printf_b
\end{verbatim}
   
{\bf (2) \_dbgpr.h の使い方}\\

\begin{verbatim}
       #define   _DBGFLG    1      //OR*  static int _DBGFLG = 1;
       #include  "_dbgpr.h"
      _DBGFLG == 1  ==> Enable debug prints
      _DBGFLG == 0  ==> Disable debug prints
\end{verbatim}

{\bf (3)  QSH の "d" コマンド}\\

        ソースプログラムは、\verb|src/9/port/_dumptbl.c|

\section{実行時間計測}
    
      ( \verb|check_clock()| などの説明を付ける)

    
\section{GCCについて}

      GCC は version によって振る舞いが異なります。
    LP49 は FedoreCore Linux 搭載の GCC-3.2 と GCC-4.1 とでコンパイルをしている。
      GCC コンパイラによっては、make 時に\verb|__stack_chk_fail| が未定義 
     というエラーに陥るもしれない。
     GCC-4からは、スタック上に確保した配列のオーバフローを実行時に検出する
    スタック保護の仕組みを取り入れたからである。
    このエラーが出た場合は、とりあえづ src/Maketool の CC の定義に
     --nostack-protector を追加してみて下さい。\\

   {\tt  CC = gcc --nostack-protector  }  \\
    

 ただし、このオプションは gcc-3.* では理解できずエラーになる。
  Makefile の中でコンパイラのversionをチ
    ェックして、オプションの着脱をおこなうべきである。

\begin{comment}
\end{comment}
\end{document}
